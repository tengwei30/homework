# 张嵩 | Part1 | Module1

## 简单题

### 第一题

结果：10
原因：for 循环中 var 定义的是函数作用域，所以会在整个 for 循环的执行完才会执行下面的操作
i 的循环结果都是 10

### 第二题

结果：123
原因：let 声明的变量不会发生变量的提升，所以此时 console 出来的是 var 声明的全局变量 123

### 第三题 -- 找数组中的最小值

```js
var arr = [12, 34, 32, 89, 4]
// const newArr = Array.from(new Set(arr)) // 有重复值的时候先去重
console.log(Math.min(...arr))
```

### 第四题 -- 说明 let/var/const 的差别

- var 声明的变量是全局作用域或者函数作用域的，const/let 声明的是块级作用域的
- var 会发生变量的提升，而 let/const 不会发生变量的提升
- const 常用来声明常量，一旦声明便不可改变（指的是内存地址的不可改变）,let 则可改变

### 第五题

结果： 20
原因： 箭头函数并没有 this 的概念，所以遇到箭头函数就会去找它外层的函数调用,
所以此时的 this 和其宿主对象 fn 的 this 指向一致，指向当前对象 obj

### 第六题 -- 简述 Symbol 类型的用途

作用：主要是用来生成一个唯一的变量，Symbol 类型的变量都是唯一的，不会造成变量污染

### 第七题 -- 浅 copy 和 深 copy

- 浅 copy：只会 copy 对象中的第一层，也就是基本基本类型的 copy，此时 obj 中的引用类型不会被 copy，俩对象的引用类型共用一套内存地址
- 深 copy: 基本类型和引用类型的都会进行 copy

### 第八题 -- 如何理解 JS 的异步编程，EventLoop 是做什么的，什么是宏任务，什么是微任务

- JS 编程： 就是利用回调函数的形式做实现让 JS 中一些耗时的工作提前执行，缩短了 JS 的执行周期
- EventLoop: 事件循环的作用 --- 因为 JS 本身是单线程执行的，所以在 JS 执行过程中如果遇到了一些阻塞性任务，
  JS 会把他们放到浏览器的事件队列中进行等待，当主线程没有任务在执行是，再从队列中依次取出任务放到主线程执行，这就是事件循环
  说白了 EventLoop 的作用就是链接了执行栈和队列的桥梁，控制着队列往执行栈 push 任务的时机
- 宏任务：就是主线程上正常执行的任务吧。像 setTimeout/setInterval 都是宏任务
- 微任务：被插入到主线程上执行的任务（感觉说法有点不严谨 😂）。像 promise 就是个微任务。微任务的优先级高于宏任务

### 第九题

```js
Promise.resolve('hello')
  .then((res) => {
    return `${res} lagou`
  })
  .then((res) => {
    const result = `${res} I love U`
    console.log(result)
  })
```

### 第十题 TS 和 JS 的关系

- 个人感觉 JS 和 TS 的关系就是 TS 相当于 JS 的一个注解的封装，给 JS 提供了语法层面上的限定，让 JS 的代码更牢靠

### 第十一题

- 优点：代码更牢靠，更便于维护和重构，错误能更早的暴露出来
- 缺点：需要写大量的注解代码
